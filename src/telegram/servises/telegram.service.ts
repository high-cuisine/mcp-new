import { Injectable, Logger } from "@nestjs/common";
import { InjectBot, On, TelegrafModule } from "nestjs-telegraf";
import { Telegraf } from "telegraf";
import { Context } from "telegraf";
import { ClientRepository } from "../../client/repositorys/client.repository";
import { RedisService } from "@infra/redis/redis.service";
import { ProccesorService } from "../../proccesor/services/proccesor.service";
import { SceneContext } from 'telegraf/typings/scenes';
import { CrmService } from "../../crm/services/crm.service";

@Injectable()
export class TelegramService {
    private readonly logger = new Logger(TelegramService.name);

    constructor(
        @InjectBot() private readonly bot: Telegraf,
        private readonly userRepository: ClientRepository,
        private readonly redisService: RedisService,
        private readonly proccesorService: ProccesorService,
    private readonly crmService: CrmService
    ) {
        this.getMe();
    }

    async getMe() {
        const me = await this.bot.telegram.getMe();
        console.log(me);
    }

    async sendMessage(ctx: SceneContext) {
        try {
            const user = await this.getUser(ctx);

            if(!user) {
                const newUser = await this.createUser(ctx);
                await ctx.reply(`–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç–∞!`);
                return;
            }

            const messages = [
                ...user.messages
                    .filter(m => m.role && m.text) // –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –≤–∞–ª–∏–¥–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
                    .map(m => ({ role: m.role, content: m.text })), 
                { role: 'user', content: (ctx.message as any)?.text }
            ];
            
            // –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
            console.log('Messages being sent to OpenAI:', JSON.stringify(messages, null, 2));

            const res = await this.proccesorService.sendMessage(messages);

            console.log(res);

            if(!res) {
                await ctx.reply('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è');
                return;
            }

            
            if(res.type === 'create_appointment') {
                await this.createAppointment(ctx as SceneContext);
            }
            if(res.type === 'channel_appointment') {
                await this.cancelAppointment(ctx as SceneContext);
            }
            if(res.type === 'show_appointment') {
                await this.showAppointment(ctx as SceneContext);      
            }
            if(res.type === 'move_appointment') {
                await this.moveAppointment(ctx as SceneContext);
            }
            if(res.type === 'text') {
                await ctx.reply(res.content || '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è');

                this.userRepository.addMessage(user._id, [
                    { text: (ctx.message as any)?.text, role: 'user' },
                    { text: res.content || res, role: 'assistant' }
                ]);
            }
            return;

            
        } catch (error) {
            console.error('Error in sendMessage:', error);
            await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è');
        }
    }

    private async getUser(ctx: Context) {
        const telegramId = ctx.from?.id?.toString();

        const userCache = await this.redisService.get(`user:${telegramId}`);
        if (userCache) {
            return JSON.parse(userCache);
        }
        const user = await this.userRepository.findByTelegramId(telegramId!);
        if (user) {
            await this.redisService.set(`user:${telegramId}`, JSON.stringify(user), { EX: 60 * 60 * 24 * 30 });
            return user;
        }
        
        return null;
    }
    
    private async createUser(ctx: Context) {
        const userCreateData = {
            telegramId: ctx.from?.id?.toString(),
            telegramName: ctx.from?.username,
            telegramNumber: ctx.from?.id,
            whatsappNumber: ctx.from?.id,
            createdAt: new Date(),
            messages: []
        }

        if(!userCreateData.telegramId || !userCreateData.telegramName || !userCreateData.telegramNumber || !userCreateData.whatsappNumber) {
            return null;
        }
        const newUser = await this.userRepository.createUser(
            userCreateData.telegramId,
            userCreateData.telegramName,
            userCreateData.telegramNumber.toString(),
            userCreateData.whatsappNumber.toString(),
            userCreateData.createdAt
        );
        return newUser;
    }
    
    async createAppointment(ctx: SceneContext) {
        const user = await this.getUser(ctx);
        if(!user) {
            await ctx.reply('–í—ã –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã');
            return;
        }

        const clinics = await this.crmService.getClinics();
        if(!clinics) {
            await ctx.reply('–ù–µ –Ω–∞–π–¥–µ–Ω–æ –∫–ª–∏–Ω–∏–∫');
            return;
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–µ—Å—Å–∏—é –µ—Å–ª–∏ –æ–Ω–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        if (!ctx.session) {
            ctx.session = {};
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–µ—Å—Å–∏—é –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø—Ä–∏–µ–º–∞
        ctx.session['createAppointment'] = {
            step: 'pet_name'
        };
          
        // –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ —Å—Ü–µ–Ω—É —Å–æ–∑–¥–∞–Ω–∏—è –ø—Ä–∏–µ–º–∞
        await ctx.scene.enter('create_appointment');
    }

    async cancelAppointment(ctx: SceneContext) {
        const user = await this.getUser(ctx);
        if(!user) {
            await ctx.reply('–í—ã –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã');
            return;
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Å—Å–∏–∏ –¥–ª—è –æ—Ç–º–µ–Ω—ã –∑–∞–ø–∏—Å–∏
        if (!ctx.session) {
            ctx.session = {};
        }
        ctx.session['cancelAppointment'] = {
            step: 'phone'
        };
        
        // –í—Ö–æ–¥ –≤ —Å—Ü–µ–Ω—É –æ—Ç–º–µ–Ω—ã –∑–∞–ø–∏—Å–∏
        return ctx.scene.enter('cancel_appointment');
    }

    async sendQrWhatsapp(qr: string) {
        try {
            // –ê–¥–º–∏–Ω—Å–∫–∏–π ID –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ QR –∫–æ–¥–∞
            const adminId = '1042650482';
            
            if (!adminId) {
                this.logger.warn('TELEGRAM_ADMIN_ID not configured');
                return;
            }

            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º QR –∫–æ–¥ –∫–∞–∫ —Ç–µ–∫—Å—Ç (ASCII art)
            await this.bot.telegram.sendMessage(adminId, 
                'üîê QR –∫–æ–¥ –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è WhatsApp\n\n' +
                '–û—Ç—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ —ç—Ç–æ—Ç QR –∫–æ–¥ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ WhatsApp –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏:\n\n' +
                '```\n' + qr + '\n```', 
                { parse_mode: 'Markdown' }
            );

            this.logger.log('QR code sent to admin');
        } catch (error) {
            this.logger.error('Failed to send QR code to admin', error);
        }
    }

    async sendMessageToAdmin(adminId: string, message: string) {
        try {
            await this.bot.telegram.sendMessage(adminId, message, { 
                parse_mode: 'Markdown' 
            });
            this.logger.log('Message sent to admin');
        } catch (error) {
            this.logger.error('Failed to send message to admin', error);
        }
    }

    async showAppointment(ctx: SceneContext) {
        if (!ctx.session) {
            ctx.session = {};
        }
        ctx.session['showAppointment'] = {
            step: 'phone'
        };
        return ctx.scene.enter('show_appointment');
    }

    async moveAppointment(ctx: SceneContext) {
        if (!ctx.session) {
            ctx.session = {};
        }
        ctx.session['moveAppointment'] = {
            step: 'phone'
        };
        return ctx.scene.enter('move_appointment');
    }
}