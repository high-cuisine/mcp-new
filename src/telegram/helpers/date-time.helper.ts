import { PaginationButton } from './pagination.helper';

export interface TimeSlot {
  time: string;
  isAvailable: boolean;
  appointmentId?: string;
}

export interface DateSlot {
  date: string;
  displayName: string;
  availableSlots: number;
  totalSlots: number;
}

export class DateTimeHelper {
  private static readonly WORK_START_HOUR = 9; // 9:00
  private static readonly WORK_END_HOUR = 18; // 18:00
  private static readonly SLOT_DURATION_HOURS = 1; // 1 —á–∞—Å –Ω–∞ –ø—Ä–∏–µ–º

  /**
   * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã–µ –¥–∞—Ç—ã –Ω–∞ –±–ª–∏–∂–∞–π—à–∏–µ –¥–Ω–∏
   * @param daysAhead - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –≤–ø–µ—Ä–µ–¥ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
   * @returns –º–∞—Å—Å–∏–≤ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–∞—Ç
   */
  static generateAvailableDates(daysAhead: number = 14): DateSlot[] {
    const dates: DateSlot[] = [];
    const today = new Date();
    
    for (let i = 0; i < daysAhead; i++) {
      const date = new Date(today);
      date.setDate(today.getDate() + i);
      
      // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å—è (–¥–µ–Ω—å –Ω–µ–¥–µ–ª–∏ 0)
      if (date.getDay() === 0) {
        continue;
      }
      
      const dateStr = date.toISOString().split('T')[0]; // YYYY-MM-DD
      const displayName = this.formatDateDisplay(date);
      const totalSlots = this.calculateTotalSlots();
      
      dates.push({
        date: dateStr,
        displayName,
        availableSlots: totalSlots, // –ë—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–æ –ø–æ—Å–ª–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–∞–Ω—è—Ç—ã—Ö —Å–ª–æ—Ç–æ–≤
        totalSlots
      });
    }
    
    return dates;
  }

  /**
   * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Å–ª–æ—Ç—ã –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –¥–∞—Ç—ã
   * @param date - –¥–∞—Ç–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ YYYY-MM-DD
   * @param occupiedSlots - –∑–∞–Ω—è—Ç—ã–µ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Å–ª–æ—Ç—ã
   * @returns –º–∞—Å—Å–∏–≤ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Å–ª–æ—Ç–æ–≤
   */
  static generateTimeSlots(date: string, occupiedSlots: string[] = []): TimeSlot[] {
    const slots: TimeSlot[] = [];
    const workStart = this.WORK_START_HOUR;
    const workEnd = this.WORK_END_HOUR;
    
    for (let hour = workStart; hour < workEnd; hour++) {
      const timeStr = `${hour.toString().padStart(2, '0')}:00`;
      const isOccupied = occupiedSlots.includes(timeStr);
      
      slots.push({
        time: timeStr,
        isAvailable: !isOccupied
      });
    }
    
    return slots;
  }

  /**
   * –°–æ–∑–¥–∞–µ—Ç –∫–Ω–æ–ø–∫–∏ –¥–ª—è –≤—ã–±–æ—Ä–∞ –¥–∞—Ç—ã —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π
   * @param dates - –º–∞—Å—Å–∏–≤ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–∞—Ç
   * @param currentPage - —Ç–µ–∫—É—â–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞
   * @returns –º–∞—Å—Å–∏–≤ –∫–Ω–æ–ø–æ–∫ –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
   */
  static createDateButtons(dates: DateSlot[], currentPage: number = 1): PaginationButton[] {
    return dates.map((dateSlot, index) => {
      const availabilityText = dateSlot.availableSlots > 0 
        ? `‚úÖ ${dateSlot.availableSlots}/${dateSlot.totalSlots}` 
        : '‚ùå –ó–∞–Ω—è—Ç–æ';
      
      return {
        text: `${dateSlot.displayName} ${availabilityText}`,
        callbackData: `date_${dateSlot.date}`
      };
    });
  }

  /**
   * –°–æ–∑–¥–∞–µ—Ç –∫–Ω–æ–ø–∫–∏ –¥–ª—è –≤—ã–±–æ—Ä–∞ –≤—Ä–µ–º–µ–Ω–∏
   * @param timeSlots - –º–∞—Å—Å–∏–≤ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Å–ª–æ—Ç–æ–≤
   * @param currentPage - —Ç–µ–∫—É—â–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞
   * @returns –º–∞—Å—Å–∏–≤ –∫–Ω–æ–ø–æ–∫ –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
   */
  static createTimeButtons(timeSlots: TimeSlot[], currentPage: number = 1): PaginationButton[] {
    return timeSlots
      .filter(slot => slot.isAvailable)
      .map(slot => ({
        text: `üïê ${slot.time}`,
        callbackData: `time_${slot.time}`
      }));
  }

  /**
   * –ü–∞—Ä—Å–∏—Ç callback –¥–∞–Ω–Ω—ã–µ –¥–ª—è –¥–∞—Ç—ã
   * @param callbackData - –¥–∞–Ω–Ω—ã–µ callback
   * @returns –¥–∞—Ç–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ YYYY-MM-DD –∏–ª–∏ null
   */
  static parseDateCallback(callbackData: string): string | null {
    const match = callbackData.match(/^date_(.+)$/);
    return match ? match[1] : null;
  }

  /**
   * –ü–∞—Ä—Å–∏—Ç callback –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Ä–µ–º–µ–Ω–∏
   * @param callbackData - –¥–∞–Ω–Ω—ã–µ callback
   * @returns –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ HH:MM –∏–ª–∏ null
   */
  static parseTimeCallback(callbackData: string): string | null {
    const match = callbackData.match(/^time_(.+)$/);
    return match ? match[1] : null;
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ callback –¥–ª—è –≤—ã–±–æ—Ä–∞ –¥–∞—Ç—ã
   * @param callbackData - –¥–∞–Ω–Ω—ã–µ callback
   * @returns true, –µ—Å–ª–∏ —ç—Ç–æ callback –¥–ª—è –¥–∞—Ç—ã
   */
  static isDateCallback(callbackData: string): boolean {
    return callbackData.startsWith('date_');
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ callback –¥–ª—è –≤—ã–±–æ—Ä–∞ –≤—Ä–µ–º–µ–Ω–∏
   * @param callbackData - –¥–∞–Ω–Ω—ã–µ callback
   * @returns true, –µ—Å–ª–∏ —ç—Ç–æ callback –¥–ª—è –≤—Ä–µ–º–µ–Ω–∏
   */
  static isTimeCallback(callbackData: string): boolean {
    return callbackData.startsWith('time_');
  }

  /**
   * –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –¥–∞—Ç—É –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
   * @param date - –æ–±—ä–µ–∫—Ç Date
   * @returns –æ—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ –¥–∞—Ç—ã
   */
  static formatDateDisplay(date: Date): string {
    const today = new Date();
    const tomorrow = new Date(today);
    tomorrow.setDate(today.getDate() + 1);
    
    if (date.toDateString() === today.toDateString()) {
      return 'üìÖ –°–µ–≥–æ–¥–Ω—è';
    } else if (date.toDateString() === tomorrow.toDateString()) {
      return 'üìÖ –ó–∞–≤—Ç—Ä–∞';
    } else {
      const dayNames = ['–í—Å', '–ü–Ω', '–í—Ç', '–°—Ä', '–ß—Ç', '–ü—Ç', '–°–±'];
      const monthNames = ['—è–Ω–≤', '—Ñ–µ–≤', '–º–∞—Ä', '–∞–ø—Ä', '–º–∞–π', '–∏—é–Ω', 
                         '–∏—é–ª', '–∞–≤–≥', '—Å–µ–Ω', '–æ–∫—Ç', '–Ω–æ—è', '–¥–µ–∫'];
      
      const dayName = dayNames[date.getDay()];
      const day = date.getDate();
      const month = monthNames[date.getMonth()];
      
      return `üìÖ ${dayName}, ${day} ${month}`;
    }
  }

  /**
   * –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª–æ—Ç–æ–≤ –≤ —Ä–∞–±–æ—á–µ–º –¥–Ω–µ
   * @returns –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ª–æ—Ç–æ–≤
   */
  private static calculateTotalSlots(): number {
    return this.WORK_END_HOUR - this.WORK_START_HOUR;
  }

  /**
   * –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç –¥–ª—è API
   * @param date - –¥–∞—Ç–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ YYYY-MM-DD
   * @param time - –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ HH:MM
   * @returns –¥–∞—Ç–∞ –∏ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –¥–ª—è API
   */
  static formatDateTimeForAPI(date: string, time: string): string {
    return `${date}T${time}:00`;
  }

  /**
   * –ü–æ–ª—É—á–∞–µ—Ç –∑–∞–Ω—è—Ç—ã–µ —Å–ª–æ—Ç—ã –∏–∑ —Å–ø–∏—Å–∫–∞ –ø—Ä–∏–µ–º–æ–≤
   * @param appointments - –º–∞—Å—Å–∏–≤ –ø—Ä–∏–µ–º–æ–≤ –∏–∑ API
   * @param targetDate - —Ü–µ–ª–µ–≤–∞—è –¥–∞—Ç–∞
   * @returns –º–∞—Å—Å–∏–≤ –∑–∞–Ω—è—Ç—ã—Ö –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Å–ª–æ—Ç–æ–≤
   */
  static getOccupiedTimeSlots(appointments: any[], targetDate: string): string[] {
    return appointments
      .filter(appointment => {
        const appointmentDate = appointment.admission_date?.split('T')[0];
        return appointmentDate === targetDate;
      })
      .map(appointment => {
        const dateTime = new Date(appointment.admission_date);
        const hours = dateTime.getHours();
        const minutes = dateTime.getMinutes();
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
      });
  }
}
