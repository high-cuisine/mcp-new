import { Markup } from 'telegraf';
import { SceneContext } from 'telegraf/typings/scenes';

export interface PaginationButton {
  text: string;
  callbackData: string;
}

export interface PaginationOptions {
  itemsPerPage?: number;
  showPageNumbers?: boolean;
  showNavigation?: boolean;
  customButtons?: PaginationButton[];
  cancelButtonText?: string;
  cancelCallbackData?: string;
}

export class PaginationHelper {
  private static readonly DEFAULT_ITEMS_PER_PAGE = 5;
  private static readonly DEFAULT_CANCEL_TEXT = '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å';
  private static readonly DEFAULT_CANCEL_CALLBACK = 'cancel';

  /**
   * –°–æ–∑–¥–∞–µ—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π –¥–ª—è —Å–ø–∏—Å–∫–∞ –∫–Ω–æ–ø–æ–∫
   * @param items - –º–∞—Å—Å–∏–≤ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
   * @param currentPage - —Ç–µ–∫—É—â–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ (–Ω–∞—á–∏–Ω–∞—è —Å 1)
   * @param options - –æ–ø—Ü–∏–∏ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
   * @returns –æ–±—ä–µ–∫—Ç —Å –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
   */
  static createPaginatedKeyboard(
    items: PaginationButton[],
    currentPage: number = 1,
    options: PaginationOptions = {}
  ) {
    const {
      itemsPerPage = this.DEFAULT_ITEMS_PER_PAGE,
      showPageNumbers = true,
      showNavigation = true,
      customButtons = [],
      cancelButtonText = this.DEFAULT_CANCEL_TEXT,
      cancelCallbackData = this.DEFAULT_CANCEL_CALLBACK
    } = options;

    const totalPages = Math.ceil(items.length / itemsPerPage);
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = Math.min(startIndex + itemsPerPage, items.length);
    const currentItems = items.slice(startIndex, endIndex);

    const keyboard: any[] = [];

    // –î–æ–±–∞–≤–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    currentItems.forEach(item => {
      keyboard.push([Markup.button.callback(item.text, item.callbackData)]);
    });

    // –î–æ–±–∞–≤–ª—è–µ–º –∫–∞—Å—Ç–æ–º–Ω—ã–µ –∫–Ω–æ–ø–∫–∏
    if (customButtons.length > 0) {
      customButtons.forEach(button => {
        keyboard.push([Markup.button.callback(button.text, button.callbackData)]);
      });
    }

    // –î–æ–±–∞–≤–ª—è–µ–º –Ω–∞–≤–∏–≥–∞—Ü–∏—é –ø–æ —Å—Ç—Ä–∞–Ω–∏—Ü–∞–º
    if (showNavigation && totalPages > 1) {
      const navigationRow: any[] = [];

      // –ö–Ω–æ–ø–∫–∞ "–ù–∞–∑–∞–¥"
      if (currentPage > 1) {
        navigationRow.push(Markup.button.callback('‚óÄÔ∏è', `page_${currentPage - 1}`));
      }

      // –ù–æ–º–µ—Ä–∞ —Å—Ç—Ä–∞–Ω–∏—Ü
      if (showPageNumbers) {
        const startPage = Math.max(1, currentPage - 2);
        const endPage = Math.min(totalPages, currentPage + 2);

        for (let i = startPage; i <= endPage; i++) {
          const isCurrentPage = i === currentPage;
          navigationRow.push(
            Markup.button.callback(
              isCurrentPage ? `[${i}]` : `${i}`,
              `page_${i}`
            )
          );
        }
      }

      // –ö–Ω–æ–ø–∫–∞ "–í–ø–µ—Ä–µ–¥"
      if (currentPage < totalPages) {
        navigationRow.push(Markup.button.callback('‚ñ∂Ô∏è', `page_${currentPage + 1}`));
      }

      if (navigationRow.length > 0) {
        keyboard.push(navigationRow);
      }
    }

    // –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É –æ—Ç–º–µ–Ω—ã
    keyboard.push([Markup.button.callback(cancelButtonText, cancelCallbackData)]);

    return {
      keyboard: Markup.inlineKeyboard(keyboard),
      paginationInfo: {
        currentPage,
        totalPages,
        totalItems: items.length,
        itemsPerPage,
        startIndex: startIndex + 1,
        endIndex
      }
    };
  }

  /**
   * –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –ø–∞–≥–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π
   * @param ctx - –∫–æ–Ω—Ç–µ–∫—Å—Ç —Å—Ü–µ–Ω—ã
   * @param message - —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
   * @param items - –º–∞—Å—Å–∏–≤ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
   * @param currentPage - —Ç–µ–∫—É—â–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞
   * @param options - –æ–ø—Ü–∏–∏ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
   */
  static async sendPaginatedMessage(
    ctx: SceneContext,
    message: string,
    items: PaginationButton[],
    currentPage: number = 1,
    options: PaginationOptions = {}
  ) {
    const { keyboard, paginationInfo } = this.createPaginatedKeyboard(items, currentPage, options);
    
    const pageInfo = options.showPageNumbers 
      ? `\n\nüìÑ –°—Ç—Ä–∞–Ω–∏—Ü–∞ ${paginationInfo.currentPage} –∏–∑ ${paginationInfo.totalPages}`
      : '';

    await ctx.replyWithHTML(message + pageInfo, keyboard);
  }

  /**
   * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç callback –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –ø–æ —Å—Ç—Ä–∞–Ω–∏—Ü–∞–º
   * @param callbackData - –¥–∞–Ω–Ω—ã–µ callback
   * @returns –Ω–æ–º–µ—Ä —Å—Ç—Ä–∞–Ω–∏—Ü—ã –∏–ª–∏ null, –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ –Ω–∞–≤–∏–≥–∞—Ü–∏—è
   */
  static parsePageCallback(callbackData: string): number | null {
    const match = callbackData.match(/^page_(\d+)$/);
    return match ? parseInt(match[1], 10) : null;
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ callback –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω—ã–º
   * @param callbackData - –¥–∞–Ω–Ω—ã–µ callback
   * @returns true, –µ—Å–ª–∏ —ç—Ç–æ –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω—ã–π callback
   */
  static isPageCallback(callbackData: string): boolean {
    return callbackData.startsWith('page_');
  }
}